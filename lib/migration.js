const fs = require('fs-extra');
const prettier = require('prettier');
const path = require('path');
const { stripIndent } = require('common-tags');
const runMigration = require('contentful-migration/built/bin/cli').runMigration;
const {
  getContentTypes,
  generateMigrationScript,
} = require('contentful-cli/lib/cmds/space_cmds/generate_cmds/migration');
const chalk = require('chalk');
const { getEnvironment } = require('./contentful');

const { confirm, STATE_SUCCESS, STATE_FAILURE } = require('./config');

const { storeMigration, getNewMigrations } = require('./backend');

const migrationHeader = stripIndent`/* eslint-env node */
  const { withHelpers } = require('@jungvonmatt/contentful-migrations');

  /**
   * Contentful migration
   * API: https://github.com/contentful/contentful-migration
   * Editor Interfaces: https://www.contentful.com/developers/docs/extensibility/app-framework/editor-interfaces/
   */
  module.exports = withHelpers(async function (migration, context, helpers) {
`;

/**
 * Create new migration file.
 * Adds initial migration file adding the migration field in the content type
 * @param {Object} config The config object including all required data
 */
const createMigration = async (config) => {
  let module = false;
  try {
    const { readPackageUp } = await import('read-pkg-up');
    const data = await readPackageUp();
    module = data?.packageJson?.type === 'module';
  } catch (err) {
    console.log(err);
  }

  const { directory } = config || {};
  const timestamp = Date.now();
  const filename = path.join(directory, `${timestamp}-migration.${module ? 'cjs' : 'js'}`);
  const content = stripIndent`${migrationHeader}
    // Add your migration code here
  })`;

  await fs.outputFile(filename, await format(filename, content));
  console.log(`Generated new migration file to ${chalk.green(filename)}`);
};

const format = async (file, content) => {
  const prettierOptions = await prettier.resolveConfig(file, { editorconfig: true });
  return prettier.format(content, {
    parser: 'babel',
    ...prettierOptions,
  });
};

/**
 * Fetch migration from contentful
 * @param {Object} config The config object including all required data
 */
const fetchMigration = async (config) => {
  const { contentType, directory } = config || {};
  const client = await getEnvironment(config);
  let module = false;
  try {
    const { readPackageUp } = await import('read-pkg-up');
    const data = await readPackageUp();
    module = data?.packageJson?.type === 'module';
  } catch (err) {
    console.log(err);
  }

  let timestamp = Date.now();
  const contentTypes = contentType
    ? (await Promise.all(contentType.map((ct) => getContentTypes(client, ct)))).flat()
    : await getContentTypes(client);

  const promises = contentTypes.map(async (entry) => {
    const filename = path.join(directory, `${timestamp++}-create-${entry.sys.id}-migration.${module ? 'cjs' : 'js'}`);

    const content = await generateMigrationScript(client, [entry]);
    // Fetch migration script generated by contentful
    let modifiedContent = content.toString();
    // Modify migration script to use our helpers
    const testDefaultValueRegex = /(defaultValue\({\s*)[^\:]+([^\)]+)/g;
    if (testDefaultValueRegex.test(modifiedContent)) {
      modifiedContent = content
        .toString()
        // Add call to utils.getDefaultLocale() to the top
        .replace(
          'module.exports = function (migration) {',
          `
          ${migrationHeader}
          const defaultLocale = await helpers.locale.getDefaultLocale();
        `
        )
        // Replace the default locale with defaultLocale.code so that the migration
        // still works as expected when the locale is changed in contentful
        .replace(testDefaultValueRegex, '$1[defaultLocale.code]$2')
        // Add a closing parentheses as we wrap the migration function.
        .replace(/};\s*$/g, '});');
    } else {
      // If we don't have a default value we just wrap the migration function with our withHelpers wrapper
      modifiedContent = content
        .toString()
        .replace('module.exports = function (migration) {', migrationHeader)
        .replace(/};\s*$/g, '});');
    }

    await fs.outputFile(filename, await format(filename, modifiedContent));
    console.log(`Generated new migration file to ${chalk.green(filename)}`);
  });

  return Promise.all(promises);
};

/**
 * Execute a single migration
 * @param {string} file Path to the migration file
 * @param {Object} config The config object including all required data
 * @returns
 */
const executeMigration = async (file, config) => {
  const { accessToken, requestBatchSize, spaceId } = config || {};
  const client = await getEnvironment(config);
  const environmentId = client.sys.id;
  const name = path.basename(file);
  const [, version] = /^(\d+)-/.exec(name);

  const options = {
    filePath: file,
    accessToken,
    spaceId,
    environmentId,
    requestBatchSize,
    yes: true,
  };

  console.log(`\nRun migration ${chalk.green(version)} in environment ${chalk.green(environmentId)}`);
  const proceed = await confirm(config);
  if (!proceed) {
    return;
  }
  try {
    await runMigration(options);
    await storeMigration({ version, name, state: STATE_SUCCESS }, config);
  } catch (error) {
    const message = (error.errors || [error]).map((error) => error.message).join('\n');
    await storeMigration({ version, name, state: STATE_FAILURE, message }, config);

    throw error;
  }

  return version;
};

/**
 *
 * @param {Object} config The config object including all required data
 */
const runMigrations = async (config) => {
  const { bail } = config || {};

  const client = await getEnvironment(config);
  const environmentId = client.sys.id;
  let migrations = [];
  try {
    migrations = await getNewMigrations(config);
  } catch (error) {
    console.log(error.message);
    throw error;
  }
  console.log(
    `Found ${chalk.green(migrations.length)} unexecuted migrations in environment ${chalk.green(environmentId)}`
  );

  const proceed = migrations.length === 0 || (await confirm(config));
  if (!proceed) {
    return;
  }

  for await (const file of migrations) {
    try {
      await executeMigration(file, { ...config, yes: true });
    } catch (error) {
      if (bail) {
        throw error;
      }
    }
  }

  console.log(chalk.green('\nAll done'), 'ðŸš€');
};

module.exports.fetchMigration = fetchMigration;
module.exports.createMigration = createMigration;
module.exports.runMigrations = runMigrations;
module.exports.executeMigration = executeMigration;
