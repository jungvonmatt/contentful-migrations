const fs = require('fs-extra');
const prettier = require('prettier');
const path = require('path');
const { stripIndent } = require('common-tags');
const runMigration = require('contentful-migration/built/bin/cli').runMigration;
const {
  getContentTypes,
  generateMigrationScript,
} = require('contentful-cli/dist/lib/cmds/space_cmds/generate_cmds/migration');
const pc = require('picocolors');
const { getEnvironment, getOrganizationId } = require('./contentful');

const { confirm, STATE_SUCCESS, STATE_FAILURE } = require('./config');

const { storeMigration, getNewMigrations } = require('./backend');

const migrationHeader = stripIndent`/* eslint-env node */
  const { withHelpers } = require('@jungvonmatt/contentful-migrations');

  /**
   * Contentful migration
   * API: https://github.com/contentful/contentful-migration
   * Editor Interfaces: https://www.contentful.com/developers/docs/extensibility/app-framework/editor-interfaces/
   */
  module.exports = withHelpers(async function (migration, context, helpers) {
`;

/**
 * Create new migration file.
 * Adds initial migration file adding the migration field in the content type
 * @param {Object} config The config object including all required data
 */
const createMigration = async (config) => {
  let module = false;
  try {
    const { readPackageUp } = await import('read-pkg-up');
    const data = await readPackageUp();
    module = data?.packageJson?.type === 'module';
  } catch (err) {
    console.log(err);
  }

  const { directory } = config || {};
  const timestamp = Date.now();
  const filename = path.join(directory, `${timestamp}-migration.${module ? 'cjs' : 'js'}`);
  const content = stripIndent`${migrationHeader}
    // Add your migration code here
  })`;

  await fs.outputFile(filename, await format(filename, content, config));
  console.log(`Generated new migration file to ${pc.green(filename)}`);
};

const format = async (file, content, config) => {
  try {
    const prettierOptions = await prettier.resolveConfig(file, { editorconfig: true });
    return prettier.format(content, {
      parser: 'babel',
      ...prettierOptions,
    });
  } catch (error) {
    if (config?.verbose) {
      console.log(pc.red('Error resolving prettier config. Using default settings.'));
      console.log();
      console.log(error);
      console.log();
    }
    return prettier.format(content, {
      parser: 'babel',
    });
  }
};

/**
 * Fetch migration from contentful
 * @param {Object} config The config object including all required data
 */
const fetchMigration = async (config) => {
  const { contentType, directory } = config || {};
  const client = await getEnvironment(config);
  let module = false;
  try {
    const { readPackageUp } = await import('read-pkg-up');
    const data = await readPackageUp();
    module = data?.packageJson?.type === 'module';
  } catch (err) {
    console.log(err);
  }

  let timestamp = Date.now();
  const contentTypes = contentType
    ? (await Promise.all(contentType.map((ct) => getContentTypes(client, ct)))).flat()
    : await getContentTypes(client);

  const promises = contentTypes.map(async (entry) => {
    const filename = path.join(directory, `${timestamp++}-create-${entry.sys.id}-migration.${module ? 'cjs' : 'js'}`);

    const content = await generateMigrationScript(client, [entry]);
    // Fetch migration script generated by contentful
    let modifiedContent = content.toString();
    // Modify migration script to use our helpers
    const testDefaultValueRegex = /(defaultValue\({\s*)[^\:]+([^\)]+)/g;
    if (testDefaultValueRegex.test(modifiedContent)) {
      modifiedContent = content
        .toString()
        // Add call to utils.getDefaultLocale() to the top
        .replace(
          'module.exports = function (migration) {',
          `
          ${migrationHeader}
          const defaultLocale = await helpers.locale.getDefaultLocale();
        `
        )
        // Replace the default locale with defaultLocale.code so that the migration
        // still works as expected when the locale is changed in contentful
        .replace(testDefaultValueRegex, '$1[defaultLocale.code]$2')
        // Add a closing parentheses as we wrap the migration function.
        .replace(/};\s*$/g, '});');
    } else {
      // If we don't have a default value we just wrap the migration function with our withHelpers wrapper
      modifiedContent = content
        .toString()
        .replace('module.exports = function (migration) {', migrationHeader)
        .replace(/};\s*$/g, '});');
    }

    await fs.outputFile(filename, await format(filename, modifiedContent, config));
    console.log(`Generated new migration file to ${pc.green(filename)}`);
  });

  return Promise.all(promises);
};

/**
 * Execute a single migration
 * @param {string} file Path to the migration file
 * @param {Object} config The config object including all required data
 * @returns
 */
const executeMigration = async (file, config) => {
  const { managementToken, requestBatchSize, spaceId } = config || {};
  const client = await getEnvironment(config);
  const environmentId = client.sys.id;
  const organizationId = await getOrganizationId(config);
  const name = path.basename(file);
  const versionMatch = name.match(/^\d+/);
  if (!versionMatch) {
    throw new Error(`Invalid migration file name ${name}. Must start with a timestamp.`);
  }
  const version = versionMatch[0];

  const options = {
    filePath: path.resolve(file),
    accessToken: managementToken,
    spaceId,
    environmentId,
    organizationId,
    requestBatchSize,
    yes: true,
  };

  if (config.host) {
    options.host = config.host;
  }

  console.log(`\nRun migration ${pc.green(version)} in environment ${pc.green(environmentId)}`);
  const proceed = await confirm(config);
  if (!proceed) {
    return;
  }
  try {
    await runMigration(options);
    await storeMigration({ version, name, state: STATE_SUCCESS }, config);
  } catch (error) {
    const message = (error.errors || [error]).map((error) => error.message).join('\n');
    await storeMigration({ version, name, state: STATE_FAILURE, message }, config);

    throw error;
  }

  return version;
};

/**
 *
 * @param {Object} config The config object including all required data
 */
const runMigrations = async (config) => {
  const { bail } = config || {};

  const client = await getEnvironment(config);
  const environmentId = client.sys.id;
  let migrations = [];
  try {
    migrations = await getNewMigrations(config);
  } catch (error) {
    console.log(error.message);
    throw error;
  }
  console.log(`Found ${pc.green(migrations.length)} unexecuted migrations in environment ${pc.green(environmentId)}`);

  const proceed = migrations.length === 0 || (await confirm(config));
  if (!proceed) {
    return;
  }

  for await (const file of migrations) {
    try {
      await executeMigration(file, { ...config, yes: true });
    } catch (error) {
      if (bail) {
        throw error;
      }
    }
  }

  console.log(pc.green('\nAll done'), 'ðŸš€');
};

module.exports.fetchMigration = fetchMigration;
module.exports.createMigration = createMigration;
module.exports.runMigrations = runMigrations;
module.exports.executeMigration = executeMigration;
